---
title: "#Rails ã® ActiveJob retry_on ã§ ãƒªãƒˆãƒ©ã‚¤æ™‚ã®å‡¦ç†ã€ãƒªãƒˆãƒ©ã‚¤ã‚’è«¦ã‚ãŸæ™‚ã®å‡¦ç†ã‚’ãã‚Œãã‚Œã«æ›¸ã ( when sur"
emoji: "ğŸ–¥"
type: "idea"
topics: ["Rails"]
published: true
---

# ãƒªãƒˆãƒ©ã‚¤ã‚’è«¦ã‚ãŸæ™‚ã®å‡¦ç†ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã§æ›¸ã‘ã‚‹

ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­ã«æ›¸ãã€‚ã“ã‚Œã£ã¦ãƒªãƒˆãƒ©ã‚¤æ™‚ã®å‡¦ç†ã˜ã‚ƒãªã„ã®ã‹ï¼è«¦ã‚ãŸæ™‚ã®å‡¦ç†ãªã®ã‹ï¼ æ„å¤–ã™ããŸã€‚


```rb
  retry_on SomeError, wait: 3.seconds, attempts: 3 do |job, exception|
    puts "JOB SURRENDERD!"
  end
```

>retry_on(*exceptions, wait: 3.seconds, attempts: 5, queue: nil, priority: nil)Link
Catch the exception and reschedule job for re-execution after so many seconds, for a specific number of attempts. If the exception keeps getting raised beyond the specified number of attempts, the exception is allowed to bubble up to the underlying queuing system, which may have its own retry mechanism or place it in a holding queue for inspection.
>
>You can also pass a block that'll be invoked if the retry attempts fail for custom logic rather than letting the exception bubble up. This block is yielded with the job instance as the first and the error instance as the second parameter.

https://api.rubyonrails.org/v6.0.0/classes/ActiveJob/Exceptions/ClassMethods.html

# ãƒªãƒˆãƒ©ã‚¤æ™‚ã«ã‚‚å¥½ããªå‡¦ç†ã‚’ã•ã›ãŸã„

retry_on ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç„¡ç†ã‚„ã‚Šä¸Šæ›¸ãã—ã¦ã¿ã‚‹ã¨ã€ã¨ã‚Šã‚ãˆãšå‹•ã„ãŸã€‚

```rb
# https://api.rubyonrails.org/v6.0.0/classes/ActiveJob/Exceptions/ClassMethods.html
# https://github.com/rails/rails/blob/66cabeda2c46c582d19738e1318be8d59584cc5b/activejob/lib/active_job/exceptions.rb#L50

class SomeJob < ApplicationJob
  queue_as :default

  class SomeError < StandardError; end

  def self.retry_on(*exceptions, wait: 3.seconds, attempts: 5, queue: nil, priority: nil)
    rescue_from(*exceptions) do |error|
      executions = executions_for(exceptions)

      if executions < attempts
        # https://github.com/rails/rails/blob/66cabeda2c46c582d19738e1318be8d59584cc5b/activejob/lib/active_job/exceptions.rb#L50
       # ã“ã“ã« puts ã‚’æŒŸã‚“ã ã ã‘
        puts "RETRY!"
        retry_job wait: determine_delay(seconds_or_duration_or_algorithm: wait, executions: executions), queue: queue, priority: priority, error: error
      else
        if block_given?
          instrument :retry_stopped, error: error do
            yield self, error
          end
        else
          instrument :retry_stopped, error: error
          raise error
        end
      end
    end
  end

  retry_on SomeError, wait: 3.seconds, attempts: 3 do |job, exception|
    puts "JOB SURRENDERD!"
  end

  def perform(message)
    raise SomeError.new('Watch out!')
  end
end

```

# Worker ã®æ¨™æº–å‡ºåŠ›ã®ä¾‹

![image](https://user-images.githubusercontent.com/13635059/65364939-3703c880-dc50-11e9-8770-f4f55454bad5.png)
![image](https://user-images.githubusercontent.com/13635059/65364941-379c5f00-dc50-11e9-89a0-3c85d8fc11e3.png)


# Original by Github issue

https://github.com/YumaInaura/YumaInaura/issues/2491








<!-- Update From Qiita API -->

# ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒ³ãƒãƒ¼å‹Ÿé›†


ä½•ã‹è³ªå•ã€æ‚©ã¿äº‹ã€ç›¸è«‡ãªã©ã‚ã‚Œã°LINEã‚ªãƒ¼ãƒ—ãƒ³ãƒãƒ£ãƒƒãƒˆã‚‚ã”åˆ©ç”¨ãã ã•ã„ã€‚

https://line.me/ti/g2/eEPltQ6Tzh3pYAZV8JXKZqc7PJ6L0rpm573dcQ





# Twitter


https://twitter.com/YumaInaura


<!-- Update From Qiita API -->


